	Коллеги, здравствуйте. Рад, вас приветствовать на десятом, юбилейном уроке курса
основы языка С. На этом уроке нас ждёт продолжение разговора о массивах.
	Массив в языке С может иметь сколько угодно измерений. Самые распространённые - это
двумерные и трёхмерные, которые легко себе представить в виде таблицы или куба. Итак
массив это структура содержащая элементы. Двумерный массив - это массив из массивов,
содержащих элементы. Трёхмерный - это массив из масиивов содержащих массивы. И так далее.
В массиве могут находиться любые типы данных, мы, для удобства, будем рассматривать работу
массивов с числами. Как работать с многомерными массивами мы рассмотрим на примере
двумерного массива. Поставим для себя задачу - сформировать таблицу Пифагора (раньше такие
на тетрадях в клетку печатали на обратной стороне). Таблица подразумевает наличие двух
измерений - строк и колонок. Создадим двумерный массив, вида table[rows][cols], где rows -
количество строк, а cols - соответственно столбцов. На самом же деле мы создали размером
rows, в каждом элементе которого содержится ссылка на массив размером cols - т.е. массив
массивов содержащих значения. Таблица Пифагора представляет собой таблицу где строки и
столбцы озаглавлены множителями а в ячейках таблицы находится их произведение.
	Сразу напишем двойной цикл, который будет выводить на экран наши созданные двумерные
массивы в удобном для нас виде.
	for(r = 0; r < rows; r++) {
		for(c = 0; c < cols; c++)
			printf("%2d ", table[r][c]);
		printf("\n");
	}
	Как это работает - внешний цикл при каждой итерации перемещает нас на одну строчку
вниз. Вложенный на каждой итерации перемещает нас на одно значение вправо. Важно понять
что на одну итерацию внешнего цикла приходится cols итераций вложенного. Т.е. с помощью
такой конструкции мы поочередно перебираем все элементы массива.
	Заполнение таких массивов значениями ничем не отличается от заполнения одномерных
массивов. Мы можем заполнять их посредством конструкции в фигурных скобках, когда мы
заранее знаем все значения. Например вот так:
	int arr[3][4] = {{0,1,2,3}, {4,5,6,7}, {8,9,10,11}} - объявляем и инициализируем
двумерный массив размером 3х4.
	Также мы можем заполнять их поэлементно, как мы сделаем это сейчас, используя тот же
двойной цикл, будем поочередно перебирать все элементы массива и присваивать им значения.
	for(r = 0; r < rows; r++)
		for(c = 0; c < cols; c++){
			table[r][c] = (r + 1) * (c + 1);
			printf("Enter value (row %d, col %d)", r, c);
			scanf("%d", &table[r][c]);
		}
	Действие (r + 1) * (c + 1) позволяет исключить 0 из нашей таблицы.

	Как уже говорилось, массивы могут содержать данные любых типов, в том числе и
указазатели. Именно это позволяет массиву хранить другие массивы, строки и прочие
ссылочные типы данных.
	char* stringArray[3] = {"Hello", "C", "World"};

	for(r = 0; r < 3; r++)
		printf("%s ", stringArray[r]);

	Используя массивы указателей мы можем создать, например, массив строк, или двумерный
массив, где каждый элемент не обязан быть того-же размера, что и остальные. Но строки и
сложно составленные указатели это темы, которые очень сильно выходят за рамки Основ языка.

До новых встреч на следующих уроках, коллеги.


#include <stdio.h>

void advancedArraysMain() {
	printf("Multi-dimensional Arrays! \n");

	const int rows = 10, cols = 10;
	int table[rows][cols];
	int r, c;

	for(r = 0; r < rows; r++)
		for(c = 0; c < cols; c++) {
			//scanf("%d", &table[r][c]);
			table[r][c] = (r + 1) * (c + 1);
		}

	for(r = 0; r < rows; r++) {
		for(c = 0; c < cols; c++)
			printf("%3d ", table[r][c]);
		printf("\n");
	}

	char* stringArray[3] = {"Hello", "C", "World!"};
	for(c = 0; c < 3; c++)
		printf("%s ", stringArray[c]);



	int twoDimensional[5][5];
	/*
	 * [][][][][]
	 * [][][][][]
	 * [][][][][]
	 * [][][][][]
	 * [][][][][]
	 */

	int threeDimensional[3][3][3]; // Rubic's cube
}
