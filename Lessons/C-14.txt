Коллеги, здравствуйте.

Рад всех приветствовать на последнем уроке курса Основ Языка С.
Это занятие последнее, но не по важности. Сильная сторона языка С не только в возможности
работать с указателями, но и в возможности самостоятельно управлять выделяемой памятью
внутри программы. В языках высокого уровня данная возможность зачастую скрыта от
программиста, чтобы по случайности не подвесить среду виртуализации.

Итак, как мы уже знаем, все переменные всех типов как-то хранятся в памяти, и до этого
момента нас устраивало как операционная система нам эту память выделяет. Но пришло время
взять бразды правления в свои руки и начать самостоятельно брать то что наше по праву.
Конечно я о памяти. Процесс выделения памяти для программы называется memory allocation
отсюда и название функции, которая выделяет память и пишет в предложенный идентификатор
указатель на начало этой области. void malloc(size);

Как видим, функция возвращает пустоту, то есть область памяти будет зафиксирована, но не
размечена. То есть некоторая область из n байт. Чтобы иметь возможность в этой области
хранить значения нам нужно её подготовить для хранения этих значений. Разметить. Например,
мы уверены, что будем складывать в нашу область памяти какие-то целые числа типа integer.
Для этого при вызове функции нам надо использовать синтаксис приведения типа полученной
области (int*) malloc(size). Это фактически говорит компилятору, что нам необходимо
выделить некоторую область памяти, поделить её на ячейки размера int, и каждой такой
ячейке дать свой адрес. Помните, мы говорили про арифметику указателей? Вот это то место,
где она нам поможет понять что вообще происходит.

	int a[SIZE];

	for(i = 0; i < SIZE; i++) a[i] = i;
	for(i = 0; i < SIZE; i++) printf("%d ", a[i]);

	puts("");

	int *b = (int*) malloc(4 * SIZE)//(sizeof(int) * SIZE);

	for(i = 0; i < SIZE; i++) *(b + i) = i;
	for(i = 0; i < SIZE; i++) printf("%d ", *(b + i));

Мы реализуем массив b вручную. то есть выполняем ровно те операции, которые выполняет
компилятор при реализации массива a. Разложили синтаксис на базовые операции. Очевидно,
что это знание открывает нам возможность распределять память в нашем приложении для любых
типов данных, в том числе и сложных, таких как структуры.

Для того, чтобы каждый раз не пересчитывать размеры переменных вручную, особенно это
актуально для строк и структур, используют оператор sizeof() который возвращает
целочисленное значение в байтах, которое займёт в памяти та или иная переменная.

Функция malloc резервирует память для нашей программы но делает это весьма просто, вместе
со всеми теми случайными переменными, которые могут там храниться. Для того чтобы
гарантированно очистить вновь выделенную область памяти используют функцию calloc() clear
allocate которая не только выделит нам память, но и очистит содержимое. Поскольку функция
не только выделяет память но и очищает её, считается, что она работает медленнее, чем
malloc. Синтаксис её весьма похож, только размеры необходимой области памяти передаются
двумя аргументами - первый - сколько элементов, второй - какого размера будут элементы.

По окончании работы с областью памяти надо её освободить, чтобы ОС могла её использовать
по своему усмотрению. Делается это при помощи функции free(). Если не освобождать память
после использования - велика вероятность того, что мы, например, в каком-то цикле будем
выделять себе место под какую-то структуру, и рано или поздно съедим всю память. Неприятно
может получиться.

И напоследок: довольно часто возникают ситуации, когда нам нужно придать нашей программе
какой-то динамики, в этом случае мы можем изменить размеры уже выделенного блока памяти.
Например, расширить наш массив, добавив туда пару элементов. Это делается при помощи
функции realloc() в которую мы должны передать указатель на область памяти, которую хотим
изменить, и размеры новой области памяти. При помощи этой функции области памяти можно как
увеличивать, так и уменьшать.

Большинство компиляторов выделяют память блоками, размеры которых обычно равны какой-то из
степеней двойки, поэтому при объявлении или изменении области памяти в 20 байт, скорее
всего будет выделена область в 32 байта, или если мы объявим 70 байт, то скорее всего
будет выделено 128. То есть при работе с областями памяти не стоит ожидать, что они будут
даваться нашей программе подряд. Организация памяти это отдельный долгий разговор, явно
выходящий за рамки Основ.

Спасибо, за внимание и интерес, проявленный к курсу. За прошедшие 14 уроков мы узнали как
устроена практически любая программа изнутри, научились работать с памятью и указателями,
узнали основные принципы и механизмы работы программ на уровне операционной системы.
Заглянули внутрь привычных синтаксических конструкций, узнали, что делают и что скрывают
от программистов среды виртуализации и фреймворки. Я и команда Гикбрейнс желает всем
успехов в освоении Ваших профессий.

Удачи и до новых встреч.


### Домашнее задание ###
 * 3. Выделение памяти.
 *    Написать функцию-обёртку, возвращающую указатель на область памяти, которую затем
 *    можно
 *    использовать как массив из элементов типа integer. Количество элементов указывается
 *    в аргументе функции. Массив должен быть гарантированно инициализирован нулями.
 *    Для проверки - заполните этот массив и выведите на экран.
 */
int* arrayInit(int l) {
	return calloc(l, sizeof(int));
}

void work_number_three() {
	// 3. mem allocation array of int
	const int ARR_SIZE = 5;
	int * array = arrayInit(ARR_SIZE);
	int i;
	for (i = 0; i < ARR_SIZE; i++)
		printf("%d ", *(array + i));
	puts("");

	for (i = 0; i < ARR_SIZE; i++)
		*(array + i) = i * 10;

	for (i = 0; i < ARR_SIZE; i++)
		printf("%d ", *(array + i));
	puts("");
}
