Здравствуйте, уважаемые коллеги. Рад всех приветствовать на одиннадцатом уроке курса Основы языка С. Получив на предыдущих уроках представление об указателях и массивах, и вскользь упомянув строки, пришла пора изучить их подробнее.

Сразу плохие новости, примитива Стринг в языке С нет. Как бы нам этого не хотелось - его нет. Но есть и хорошие новости - примитива Стринг не существует и в других языках (я имею ввиду, конечно, языки со строгой статической типизацией). Строка - это всегда ссылочный тип данных. Строка - это всегда какой-то класс, у которого есть как-то хранящиеся данные и много по-разному реализованных методов для работы с этими данными. 

Язык С не исключение - здесь тоже как-то хранятся данные и есть функции для работы с ними. Разве что класса, объединяющего это в один тип нет. Но это потому что здесь в принципе нет классов. Итак что же такое строка? Строка это набор символов, которые мы можем откуда-то прочитать, сформировать самостоятельно, записать куда-то, или вывести пользователю. Строки принято называть типом данных, но по большому счёту - это не так. Если строка и является типом данных - то самым сложным и замороченным. Строками мы пользуемся с самого первого занятия, написав в двойных кавычках Привет Мир мы использовали строку. Строки в языке С можно описать двумя способами - как указатель и как массив из переменных типа ЧАР. 
	char string1[255] = “Hello World!”;
	char* string2 = “Hey, friend!”;
У применения каждого из способов есть свои особенности. Так, например в массиве из переменных типа чар мы можем записывать, удалять и изменять символы. Например, string[5] = ‘X’; и символ с пятым индексом изменится. Указатель на тип ЧАР нам такой  возможности не даёт. Зато указатели на строки мы можем возвращать из функций. char* helloFunction () { return "Hello!"; }
и это открывает перед нами широчайшие возможности по работе с текстами. Параллельно с написанием нашей функции, приветствующей мир давайте изучим некоторые стандартные возможности языка С для работы со строками. Например, специальную функцию, которая призвана выводить строки в консоль puts(); работает она очень похожим на printf() образом, но может выводить только строки, без каких-то других параметров. А также специальную функцию gets() которая призвана считывать строки из консоли и записывать их в переменные. 	
char name[255]; gets(name); puts(name);
Теперь, казалось бы, мы можем поприветствовать пользователя нашей программы как следует, по имени. В нашей существовавшей функции приветствия внесём небольшие изменения. Создадим строку, в которой будем хранить приветственное слово, и в которую будет дописываться имя пользователя. Применим функцию склеивания строк. Поскольку склеивание - ненаучный термин, будем использовать слово конкатенация. И это слово подсказывает нам название функции, которую мы будем использовать strcat(). функция принимает на вход два параметра - строку, к которой нужно что-то прибавить, и строку, которую нужно прибавить. логично предположить, что первая строка должна быть изменяемой (то есть являться массивом символов). Функция прибавит все символы второй строки в первую и вернёт указатель на изменённую строку. Очень удобно.
char* helloFunction (char* name) {
	char welcome[255] = "Hello, ";
	return strcat(welcome, name);
}
Но, не тут то было. Мы можем возвращать из функции только фиксированные строки, как в предыдущем примере. То есть, получается, нужно писать кейс, в котором содержатся все возможные имена, и оператором switch перебирать все возможные варианты ввода, иначе мы устраиваем утечку памяти, создавая болтающийся в воздухе указатель? Нет, нас это не устраивает. Что же делать? Какой-бы мы ни создали указатель в функции - он перестанет существовать как только мы выйдем из функции. Выход очень простой - раз указатель не идёт в мэйн, надо чтобы мэйн дал нам указатель. 
void helloFunction (char* name, char* out) {
	char welcome[255] = “Hello, ”;
	out = strcat(welcome, name);
}
Если присмотреться - то все функции работающие со строками именно так и делают - запрашивают источник данных и конечную точку, куда данные нужно положить. А кто мы такие, чтобы спорить с библиотечными функциями? Обратите внимание на то, что функция strcat возвращает указатель на получившуюся строку, а наша функция возвращает void. мы также можем возвращать указатель на строку, но тут встаёт вопрос о вызывающем функцию контексте, не потеряем-ли мы получившийся указатель, и не будет ли он висеть в воздухе. Работа со строками до сих пор является очень и очень актуальной на программистских форумах, можете удостовериться.
Давайте рассмотрим ещё пару функций. Например, сравнение строк, допустим, пусть именно меня программа приветствует как-то иначе. Функция возвращает отрицательные значения, если первая строка меньше второй, положительные, если первая больше второй, и 0 если строки равны. Это функция, которую удобно применять в условиях. И копирование строк, также принимающую на вход две переменных - куда копировать, и что копировать. 
	if (strcmp("Ivan", name) == 0)
		strcpy(name, "Master!");
Полный список функций для работы со строками можно посмотреть в заголовочном файле string.h. Описание и механика их работы легко гуглится, документации по языку очень много.

В завершение беседы о строках надо сказать пару слов об обработке символов. фнкции для работы с символами содержатся в заголовочном файле stdlib.h. Естественно, наша программа может получить какие-то значения в виде строк. Не всегда же есть возможность использовать scanf(); например, считывание из графических полей ввода даёт нашей программе значения в виде строк. В языке С есть функции для работы с каждым символом строки: isalpha(), isdigit(), isspace(), isupper(), islower(), toupper(), tolower(). Можем использовать одну из них соответственно нашей задаче, допустим, пользователь может вводить своё имя как с заглавной буквы, так и всеми строчными. Уравняем оба варианта для нашей проверки одной строкой name[0] = tolower(name[0]); 
а после проверки вернём заглавную букву на место
name[0] = toupper(name[0]); 
и удостоверимся что даже если мы напишем своё имя с маленькой буквы - программа напишет его с большой.
Из всех функций для работы со строками чрезвычайно часто используются atoi(); atof() переводящие написанные в строке цифра в численные переменные внутри программы.
	char num[255];
	puts("Enter a number: ");
	gets(num);
	int number = atoi(num);
	number *= number;

	printf("We powered your number to %d", number);
Естественно, что со строкой мы такую операцию произвести не можем из-за разницы типов. 

На этом уроке мы познакомились со строками, способами работы с ними и немного улучшили понимание механизма работы программ. До встречи на следующем уроке.
