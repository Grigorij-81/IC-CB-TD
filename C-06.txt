Здравствуйте, коллеги. Я рад приветствовать вас на шестом занятии Основы Языка С. На этом
видеоуроке мы всесторонне рассмотрим такое понятие языка С, как функции, и заглянем в ту
часть программы, которая называется заголовочный файл. Начнём с функций.

Функция - это такая обособленная часть кода, которую можно выполнять любое количество раз.
У функций обязательно в таком порядке должны быть описаны тип возвращаемого значения,
название, аргументы и так называемое тело, то есть собственно исполняемый код. Рассмотрим
более детально функцию main():
    - int это тип возвращаемого значения, то есть на том месте, где будет вызвана эта
	функция в результате её работы по выполнении оператора return появится некое целое
	число. Возвращаемые значения могут быть любых типов. В случае же когда функция не
	должна возвращать результат своей работы, указывается ключевое слово void (что
	переводится с английского пустота). То есть на месте вызова функции в результате
	её выполнения ничего не появится.
    - main это название функции. Функция именно с таким названием, написанным с маленькой
	буквы является точкой входа в программу. ОС ищет именно эту функцию, когда
	получает команду на выполнение программы. Названия функций в рамках одной
	программы не должны повторяться, никаких других ограничений на название не
	накладывается.
    - (int argc, char* argv[]) это аргументы функции. Аргументы функции - это такие
	переменные, которые создаются при вызове функции и существуют только внутри
	функции, с их помощью можно передать в функцию какие-то исходные данные и
	параметры. аргументы пишутся в круглых скобках сразу после названия функции. В
	случае если функция не принимает аргументов необходимо поставить после названия
	пустые круглые скобки.
    - весь код, содержащийся в фигурных скобках после аргументов функции - называется
	телом функции. Это те операторы и команды, которые будут последовательно выполнены
	при вызове функции. В теле функции мы можем вызывать другие функции, никаких
	ограничений на написание тела функции язык не накладывает.
	Функции принято разделять на проверяющие, считающие и выводящие, и каждая из
	вышеописанных функций не должна нести дополнительной нагрузки. То есть, функция не
	должна знать откуда в программе появились её аргументы, и где будет использован
	результат её работы. Для примера опишем функцию суммирующую два числа. в качестве
	аргументов она будет принимать целые числа и возвращать целочисленный результат.
	Обратите внимание что функция не знает откуда взялись эти числа, мы можем их
	считать с консоли, можем задать в виде констант или получить в результате работы
	какой то другой функции.

*Аргументы функции
Как уже было сказано - аргументы - это переменные, которые хранят в себе некоторые
параметры вызова функции. Аргументы позволяют использовать одни и те же функции с разными
исходными данными. Приглядимся повнимательнее к хорошо знакомой нам функции printf().
Строка, которую мы пишем в круглых скобках это и есть аргумент функции. То есть мы знаем,
что функция умеет выводить на экран строки. Как именно - нам нет дела, а какие именно
строки - мы указываем в качестве аргумента.

Мы без проблем можем оформить уже существующие у нас программы. Например, оформим в виде
функций программу проверки простоты числа.

Теперь мы можем написать программы любой сложности, содержащие эту функцию. О том, что мы
работаем с консолью, в нашем случае должна знать только функция main поэтому ввод значений
и вывод на экран мы оставим в ней, а подсчёты значений положим в функции.
Прототипы функций
Зачастую возникают ситуации, когда функция не описана до точки входа в программу, или
вовсе лежит в другом файле. В этом случае мы должны сообщить компилятору, что такую
функцию придётся дополнительно поискать. Для этого необходимо указать всю информацию о
функции, кроме её тела. Такой оператор называется прототип функции.

И пара слов о заголовочных файлах. Заголовочные файлы это мощный инструмент модульной
разработки. Мы уже неоднократно видели подключение заголовочного файла stdio.h, давайте
посмотрим, что же скрывает и как именно работает эта строка. Обнаружив данный файл на
диске мы видим, что в нём содержатся другие подключения библиотек, директивы препроцессора
(о которых более подробно мы будем говорить на следующих занятиях) и прототипы функций
(например, так часто используемой нами printf(259)). То есть написав строку с ключевым
словом include мы попросили компилятор скопировать весь код заголовочного файла в нашу
программу. Зная это мы можем написать свой собственный заголовочный файл. Создадим в папке
проекта новый заголовочный файл с каким-нибудь совершенно неожиданным названием “header.h”
и скопируем наши сегодняшние труды в него. Теперь для того чтобы воспользоваться этими
функциями из любой программы, которую мы будем писать в дальнейшем, нам всего-лишь нужно
подключить наш вновь созданный заголовочный  файл к нашему проекту. Заголовочные файлы,
имена которых написаны в треугольных скобках среда разработки будет искать в папке где
содержится компилятор, а написанные в двойных кавычках по пути, относительному папки
проекта. Так мы можем создать некую общую библиотеку для наших проектов и при
необходимости обращаться к ней.
Немного красивее оформим вывод в консоль, добавив текст запроса суммируемого числа, и
поправим сам код программы, и запустим ещё раз. Теперь не стыдно это показывать.

На следующем уроке мы поговорим об указателях, и передаче аргументов по значению и по
ссылке. До новых встреч.
