Здравствуйте, коллеги, рад всех приветствовать на восьмом занятии по Основам языка С. На этом уроке нас с вами ждут массивы и ещё пара слов о директивах компилятору, также называемых директивами препроцессора. С них и начнём.

 Помимо уже хорошо знакомой вам директивы #include естественно, существуют и другие. Некоторые вы могли заметить в созданном для нас средой разработки заголовочном файле. Они ограничивают импорт описанных в заголовочном файле функций, дословно (если ещё не описаны, описать, конец условия). Вот, директиву ОПИСАТЬ мы и рассмотрим подробнее. Она не зря называется директивой препроцессора, поскольку даёт указание не процессору во время выполнения программы выделить память, присвоить значения, а непосредственно компилятору - заменить в тексте программы одни слова на другие. Например, таким образом можно задавать константы проекта, напишем #define ARRAY_LENGTH 50 и это будет означать, что компилятор, перед тем как запустить нашу программу заменит все слова ARRAY_LENGTH на цифру 50. Весьма удобно, но этим можно не ограничиваться, мы можем попросить  компилятор заменить целые вызовы функций и операторы на короткие, удобные нам слова. Иногда в программах можно встретить описание недостающего но такого привычного булевого типа при помощи директив препроцессора #define boolean int #define true 1 #define false 0. Но нам с вами пока что достаточно умения создать глобальную именованную константу.

Перейдём к обещанным массивам. Массив - это некоторое множество данных одного типа. Язык С строго типизирован, поэтому невозможно создать массив из разных типов данных. На данном этапе мы рассматриваем только статические типы данных, поэтому и массивы будем рассматривать статические. Статическим массивом называют массив, количество элементов которого заранее известно и не изменяется. Статические массивы принято объявлять двумя способами:
	 int arr[ARRAY_LENGTH];
и затем поэлементно заполнять его
	arr[0] = 10; arr[1] = 20; arr[2] = 30;
Обратите внимание, что язык С не гарантирует что инициализационное значение элементов массива будет равно нулю, если это не указано явно. 
Или, если массив небольшой, и значения его заранее известны сразу:
	int arr[5] = {0, 1, 2, 3, 4};
Таким образом видим, что при помощи указания индекса в квадратных скобках получают доступ к элементам массива. При помощи массивов решают множество задач, таких как поиск, сортировка, составление таблиц соответствия, создание частотных диаграмм. 
Напишем, для примера, программу, которая проверит насколько статистически хорош описанный в стандартной библиотеке генератор случайных чисел. Для такой статистической проверки нам понадобится сформировать так называемый частотный массив. Массив, в котором будет содержаться информация о том, сколько раз то или иное число появилось во множестве, полученном при помощи генератора псевдослучайных чисел.
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define ARRAY_LENGTH 10
#define NUMBERS_AMOUNT 1000000

int main( int argc, char *argv[])
{
	srand(time(NULL)); // зададим начальное значение ГПСЧ
	int frequency[ARRAY_LENGTH] = {0}; // объявим и обнулим
	int a, i;
	for (i = 0; i < NUMBERS_AMOUNT; i++) {	// заполним
		a = rand() % ARRAY_LENGTH;	// сгенерируем
		frequency[a]++;	// для числа 0 увеличим значение в 0-й ячейке массива, для числа 1 - в 1-й, и т.д.
	}чм наз так мас кот показ колво вхожд объекта в нек наборе
	for (i = 0; i < ARRAY_LENGTH; i++) {	// выведем
		printf("Number %d generated %6d (%5.2f%%)
times\n", i, frequency[i], ((float)frequency[i] / NUMBERS_AMOUNT * 100));
// количество вхождений и подсчёт процентов
	}
	return 0;
}
Данная программа наглядно демонстрирует не только работу с массивами, но и то, что генератор псевдослучайных чисел в языке С генерирует статистически верную последовательность случайных чисел. До встречи на следующем занятии.
